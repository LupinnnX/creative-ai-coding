import { pool } from './connection';
export type JobStatus = 'pending' | 'running' | 'completed' | 'failed' | 'cancelled';
export type JobLogLevel = 'debug' | 'info' | 'warn' | 'error';
export interface Job { id: string; job_type: string; job_name: string | null; status: JobStatus; priority: number; payload: Record<string, unknown>; result: Record<string, unknown> | null; error_message: string | null; attempts: number; max_attempts: number; retry_after: Date | null; conversation_id: string | null; session_id: string | null; agent: string | null; user_identifier: string | null; created_at: Date; started_at: Date | null; completed_at: Date | null; timeout_seconds: number; metadata: Record<string, unknown>; }
export interface CreateJobInput { job_type: string; job_name?: string; payload: Record<string, unknown>; priority?: number; max_attempts?: number; timeout_seconds?: number; conversation_id?: string; session_id?: string; agent?: string; user_identifier?: string; metadata?: Record<string, unknown>; }
export interface JobLog { id: string; job_id: string; timestamp: Date; level: JobLogLevel; message: string; data: Record<string, unknown> | null; }
export interface JobQueueStats { pending: number; running: number; completed: number; failed: number; cancelled: number; total: number; avgDurationMs: number | null; }
export async function createJob(i: CreateJobInput): Promise<Job> { const r = await pool.query<Job>('INSERT INTO nova_jobs (job_type, job_name, payload, priority, max_attempts, timeout_seconds, conversation_id, session_id, agent, user_identifier, metadata) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11) RETURNING *', [i.job_type, i.job_name || null, JSON.stringify(i.payload), i.priority ?? 50, i.max_attempts ?? 3, i.timeout_seconds ?? 300, i.conversation_id || null, i.session_id || null, i.agent || null, i.user_identifier || null, JSON.stringify(i.metadata || {})]); return r.rows[0]; }
export async function getJob(id: string): Promise<Job | null> { const r = await pool.query<Job>('SELECT * FROM nova_jobs WHERE id = $1', [id]); return r.rows[0] || null; }
export async function claimNextJob(types?: string[]): Promise<Job | null> { const f = types?.length ? 'AND job_type = ANY($1)' : ''; const p = types?.length ? [types] : []; const q = 'UPDATE nova_jobs SET status = ' + "'running'" + ', started_at = NOW(), attempts = attempts + 1 WHERE id = (SELECT id FROM nova_jobs WHERE status = ' + "'pending'" + ' AND (retry_after IS NULL OR retry_after <= NOW()) ' + f + ' ORDER BY priority DESC, created_at ASC LIMIT 1 FOR UPDATE SKIP LOCKED) RETURNING *'; const r = await pool.query<Job>(q, p); return r.rows[0] || null; }
export async function completeJob(id: string, res: Record<string, unknown>): Promise<Job | null> { const r = await pool.query<Job>('UPDATE nova_jobs SET status = $1, result = $2, completed_at = NOW() WHERE id = $3 RETURNING *', ['completed', JSON.stringify(res), id]); return r.rows[0] || null; }
export async function failJob(id: string, err: string, retry = true): Promise<Job | null> { const j = await getJob(id); if (!j) return null; const sr = retry && j.attempts < j.max_attempts; const d = Math.pow(2, j.attempts) * 1000; const r = await pool.query<Job>('UPDATE nova_jobs SET status = $1, error_message = $2, completed_at = CASE WHEN $1 = $3 THEN NOW() ELSE NULL END, retry_after = CASE WHEN $1 = $4 THEN NOW() + ($5 || $6)::interval ELSE NULL END WHERE id = $7 RETURNING *', [sr ? 'pending' : 'failed', err, 'failed', 'pending', d.toString(), ' milliseconds', id]); return r.rows[0] || null; }
export async function cancelJob(id: string): Promise<Job | null> { const r = await pool.query<Job>('UPDATE nova_jobs SET status = $1, completed_at = NOW() WHERE id = $2 AND status IN ($3, $4) RETURNING *', ['cancelled', id, 'pending', 'running']); return r.rows[0] || null; }
export async function retryJob(id: string): Promise<Job | null> { const r = await pool.query<Job>('UPDATE nova_jobs SET status = $1, error_message = NULL, retry_after = NULL, completed_at = NULL WHERE id = $2 AND status IN ($3, $4) RETURNING *', ['pending', id, 'failed', 'cancelled']); return r.rows[0] || null; }
export async function getJobsByConversation(cid: string, lim = 20): Promise<Job[]> { const r = await pool.query<Job>('SELECT * FROM nova_jobs WHERE conversation_id = $1 ORDER BY created_at DESC LIMIT $2', [cid, lim]); return r.rows; }
export async function getJobsByStatus(s: JobStatus, lim = 50): Promise<Job[]> { const r = await pool.query<Job>('SELECT * FROM nova_jobs WHERE status = $1 ORDER BY created_at DESC LIMIT $2', [s, lim]); return r.rows; }
export async function getJobsByUser(uid: string, lim = 20): Promise<Job[]> { const r = await pool.query<Job>('SELECT * FROM nova_jobs WHERE user_identifier = $1 ORDER BY created_at DESC LIMIT $2', [uid, lim]); return r.rows; }
export async function getJobQueueStats(h = 24): Promise<JobQueueStats> { const r = await pool.query<{ status: JobStatus; count: string }>('SELECT status, COUNT(*) as count FROM nova_jobs WHERE created_at > NOW() - ($1 || $2)::interval GROUP BY status', [h.toString(), ' hours']); const s: JobQueueStats = { pending: 0, running: 0, completed: 0, failed: 0, cancelled: 0, total: 0, avgDurationMs: null }; for (const row of r.rows) { const c = parseInt(row.count, 10); s[row.status] = c; s.total += c; } const a = await pool.query<{ avg_ms: string | null }>('SELECT AVG(EXTRACT(EPOCH FROM (completed_at - started_at)) * 1000) as avg_ms FROM nova_jobs WHERE status = $1 AND started_at IS NOT NULL AND completed_at IS NOT NULL AND created_at > NOW() - ($2 || $3)::interval', ['completed', h.toString(), ' hours']); if (a.rows[0]?.avg_ms) s.avgDurationMs = Math.round(parseFloat(a.rows[0].avg_ms)); return s; }
export async function getPendingJobsCount(): Promise<number> { const r = await pool.query<{ count: string }>('SELECT COUNT(*) as count FROM nova_jobs WHERE status = $1', ['pending']); return parseInt(r.rows[0]?.count || '0', 10); }
export async function getRunningJobsCount(): Promise<number> { const r = await pool.query<{ count: string }>('SELECT COUNT(*) as count FROM nova_jobs WHERE status = $1', ['running']); return parseInt(r.rows[0]?.count || '0', 10); }
export async function addJobLog(jid: string, lvl: JobLogLevel, msg: string, data?: Record<string, unknown>): Promise<JobLog> { const r = await pool.query<JobLog>('INSERT INTO nova_job_logs (job_id, level, message, data) VALUES ($1, $2, $3, $4) RETURNING *', [jid, lvl, msg, data ? JSON.stringify(data) : null]); return r.rows[0]; }
export async function getJobLogs(jid: string, lim = 100): Promise<JobLog[]> { const r = await pool.query<JobLog>('SELECT * FROM nova_job_logs WHERE job_id = $1 ORDER BY timestamp DESC LIMIT $2', [jid, lim]); return r.rows; }
export async function cleanupOldJobs(days = 7): Promise<number> { const r = await pool.query('DELETE FROM nova_jobs WHERE status IN ($1, $2, $3) AND completed_at < NOW() - ($4 || $5)::interval', ['completed', 'failed', 'cancelled', days.toString(), ' days']); return r.rowCount || 0; }
export async function timeoutStaleJobs(): Promise<number> { const r = await pool.query('UPDATE nova_jobs SET status = $1, error_message = $2, completed_at = NOW() WHERE status = $3 AND started_at < NOW() - (timeout_seconds || $4)::interval', ['failed', 'Job timed out', 'running', ' seconds']); return r.rowCount || 0; }
export async function updateJobPriority(id: string, p: number): Promise<Job | null> { if (p < 0 || p > 100) throw new Error('Priority must be between 0 and 100'); const r = await pool.query<Job>('UPDATE nova_jobs SET priority = $1 WHERE id = $2 AND status = $3 RETURNING *', [p, id, 'pending']); return r.rows[0] || null; }